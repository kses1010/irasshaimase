{"version":3,"file":"withSentryAPI.js","sources":["../../../../src/config/wrappers/withSentryAPI.ts"],"sourcesContent":["import { captureException, getCurrentHub, startTransaction } from '@sentry/node';\nimport { extractTraceparentData, hasTracingEnabled } from '@sentry/tracing';\nimport {\n  addExceptionMechanism,\n  baggageHeaderToDynamicSamplingContext,\n  isString,\n  logger,\n  objectify,\n  stripUrlQueryAndFragment,\n} from '@sentry/utils';\nimport * as domain from 'domain';\n\nimport { formatAsCode, nextLogger } from '../../utils/nextLogger';\nimport type { AugmentedNextApiRequest, AugmentedNextApiResponse, NextApiHandler, WrappedNextApiHandler } from './types';\nimport { autoEndTransactionOnResponseEnd, finishTransaction, flushQueue } from './utils/responseEnd';\n\n/**\n * Wrap the given API route handler for tracing and error capturing. Thin wrapper around `withSentry`, which only\n * applies it if it hasn't already been applied.\n *\n * @param maybeWrappedHandler The handler exported from the user's API page route file, which may or may not already be\n * wrapped with `withSentry`\n * @param parameterizedRoute The page's route, passed in via the proxy loader\n * @returns The wrapped handler\n */\nexport function withSentryAPI(\n  maybeWrappedHandler: NextApiHandler | WrappedNextApiHandler,\n  parameterizedRoute: string,\n): WrappedNextApiHandler {\n  // Log a warning if the user is still manually wrapping their route in `withSentry`. Doesn't work in cases where\n  // there's been an intermediate wrapper (like `withSentryAPI(someOtherWrapper(withSentry(handler)))`) but should catch\n  // most cases. Only runs once per route. (Note: Such double-wrapping isn't harmful, but we'll eventually deprecate and remove `withSentry`, so\n  // best to get people to stop using it.)\n  if (maybeWrappedHandler.name === 'sentryWrappedHandler') {\n    const [_sentryNextjs_, _autoWrapOption_, _withSentry_, _route_] = [\n      '@sentry/nextjs',\n      'autoInstrumentServerFunctions',\n      'withSentry',\n      parameterizedRoute,\n    ].map(phrase => formatAsCode(phrase));\n\n    nextLogger.info(\n      `${_sentryNextjs_} is running with the ${_autoWrapOption_} flag set, which means API routes no longer need to ` +\n        `be manually wrapped with ${_withSentry_}. Detected manual wrapping in ${_route_}.`,\n    );\n  }\n\n  return withSentry(maybeWrappedHandler, parameterizedRoute);\n}\n\n/**\n * Legacy function for manually wrapping API route handlers, now used as the innards of `withSentryAPI`.\n *\n * @param origHandler The user's original API route handler\n * @param parameterizedRoute The route whose handler is being wrapped. Meant for internal use only.\n * @returns A wrapped version of the handler\n */\nexport function withSentry(origHandler: NextApiHandler, parameterizedRoute?: string): WrappedNextApiHandler {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  return async function sentryWrappedHandler(req: AugmentedNextApiRequest, res: AugmentedNextApiResponse) {\n    // We're now auto-wrapping API route handlers using `withSentryAPI` (which uses `withSentry` under the hood), but\n    // users still may have their routes manually wrapped with `withSentry`. This check makes `sentryWrappedHandler`\n    // idempotent so that those cases don't break anything.\n    if (req.__withSentry_applied__) {\n      return origHandler(req, res);\n    }\n    req.__withSentry_applied__ = true;\n\n    // use a domain in order to prevent scope bleed between requests\n    const local = domain.create();\n    local.add(req);\n    local.add(res);\n\n    // `local.bind` causes everything to run inside a domain, just like `local.run` does, but it also lets the callback\n    // return a value. In our case, all any of the codepaths return is a promise of `void`, but nextjs still counts on\n    // getting that before it will finish the response.\n    const boundHandler = local.bind(async () => {\n      let transaction;\n      const currentScope = getCurrentHub().getScope();\n\n      if (currentScope) {\n        currentScope.setSDKProcessingMetadata({ request: req });\n\n        if (hasTracingEnabled()) {\n          // If there is a trace header set, extract the data from it (parentSpanId, traceId, and sampling decision)\n          let traceparentData;\n          if (req.headers && isString(req.headers['sentry-trace'])) {\n            traceparentData = extractTraceparentData(req.headers['sentry-trace']);\n            __DEBUG_BUILD__ && logger.log(`[Tracing] Continuing trace ${traceparentData?.traceId}.`);\n          }\n\n          const baggageHeader = req.headers && req.headers.baggage;\n          const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggageHeader);\n\n          // prefer the parameterized route, if we have it (which we will if we've auto-wrapped the route handler)\n          let reqPath = parameterizedRoute;\n\n          // If not, fake it by just replacing parameter values with their names, hoping that none of them match either\n          // each other or any hard-coded parts of the path\n          if (!reqPath) {\n            const url = `${req.url}`;\n            // pull off query string, if any\n            reqPath = stripUrlQueryAndFragment(url);\n            // Replace with placeholder\n            if (req.query) {\n              for (const [key, value] of Object.entries(req.query)) {\n                reqPath = reqPath.replace(`${value}`, `[${key}]`);\n              }\n            }\n          }\n\n          const reqMethod = `${(req.method || 'GET').toUpperCase()} `;\n\n          transaction = startTransaction(\n            {\n              name: `${reqMethod}${reqPath}`,\n              op: 'http.server',\n              ...traceparentData,\n              metadata: {\n                dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,\n                source: 'route',\n                request: req,\n              },\n            },\n            // extra context passed to the `tracesSampler`\n            { request: req },\n          );\n          currentScope.setSpan(transaction);\n\n          autoEndTransactionOnResponseEnd(transaction, res);\n        }\n      }\n\n      try {\n        const handlerResult = await origHandler(req, res);\n\n        if (process.env.NODE_ENV === 'development' && !process.env.SENTRY_IGNORE_API_RESOLUTION_ERROR) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `[sentry] If Next.js logs a warning \"API resolved without sending a response\", it's a false positive, which we're working to rectify.\n            In the meantime, to suppress this warning, set \\`SENTRY_IGNORE_API_RESOLUTION_ERROR\\` to 1 in your env.\n            To suppress the nextjs warning, use the \\`externalResolver\\` API route option (see https://nextjs.org/docs/api-routes/api-middlewares#custom-config for details).`,\n          );\n        }\n\n        return handlerResult;\n      } catch (e) {\n        // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can\n        // store a seen flag on it. (Because of the one-way-on-Vercel-one-way-off-of-Vercel approach we've been forced\n        // to take, it can happen that the same thrown object gets caught in two different ways, and flagging it is a\n        // way to prevent it from actually being reported twice.)\n        const objectifiedErr = objectify(e);\n\n        if (currentScope) {\n          currentScope.addEventProcessor(event => {\n            addExceptionMechanism(event, {\n              type: 'instrument',\n              handled: true,\n              data: {\n                wrapped_handler: origHandler.name,\n                function: 'withSentry',\n              },\n            });\n            return event;\n          });\n\n          captureException(objectifiedErr);\n        }\n\n        // Because we're going to finish and send the transaction before passing the error onto nextjs, it won't yet\n        // have had a chance to set the status to 500, so unless we do it ourselves now, we'll incorrectly report that\n        // the transaction was error-free\n        res.statusCode = 500;\n        res.statusMessage = 'Internal Server Error';\n\n        // Make sure we have a chance to finish the transaction and flush events to Sentry before the handler errors\n        // out. (Apps which are deployed on Vercel run their API routes in lambdas, and those lambdas will shut down the\n        // moment they detect an error, so it's important to get this done before rethrowing the error. Apps not\n        // deployed serverlessly will run into this cleanup code again in `res.end(), but the transaction will already\n        // be finished and the queue will already be empty, so effectively it'll just no-op.)\n        await finishTransaction(transaction, res);\n        await flushQueue();\n\n        // We rethrow here so that nextjs can do with the error whatever it would normally do. (Sometimes \"whatever it\n        // would normally do\" is to allow the error to bubble up to the global handlers - another reason we need to mark\n        // the error as already having been captured.)\n        throw objectifiedErr;\n      }\n    });\n\n    // Since API route handlers are all async, nextjs always awaits the return value (meaning it's fine for us to return\n    // a promise here rather than a real result, and it saves us the overhead of an `await` call.)\n    return boundHandler();\n  };\n}\n"],"names":[],"mappings":";;;;;;;;AAgBA;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;AAoBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgJA;;"}