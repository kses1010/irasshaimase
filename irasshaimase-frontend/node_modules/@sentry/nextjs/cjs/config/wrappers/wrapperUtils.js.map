{"version":3,"file":"wrapperUtils.js","sources":["../../../../src/config/wrappers/wrapperUtils.ts"],"sourcesContent":["import { captureException, getCurrentHub, startTransaction } from '@sentry/core';\nimport { getActiveTransaction } from '@sentry/tracing';\nimport { Transaction } from '@sentry/types';\nimport { baggageHeaderToDynamicSamplingContext, extractTraceparentData } from '@sentry/utils';\nimport * as domain from 'domain';\nimport { IncomingMessage, ServerResponse } from 'http';\n\nimport { autoEndTransactionOnResponseEnd } from './utils/responseEnd';\n\ndeclare module 'http' {\n  interface IncomingMessage {\n    _sentryTransaction?: Transaction;\n  }\n}\n\n/**\n * Grabs a transaction off a Next.js datafetcher request object, if it was previously put there via\n * `setTransactionOnRequest`.\n *\n * @param req The Next.js datafetcher request object\n * @returns the Transaction on the request object if there is one, or `undefined` if the request object didn't have one.\n */\nexport function getTransactionFromRequest(req: IncomingMessage): Transaction | undefined {\n  return req._sentryTransaction;\n}\n\nfunction setTransactionOnRequest(transaction: Transaction, req: IncomingMessage): void {\n  req._sentryTransaction = transaction;\n}\n\n/**\n * Wraps a function that potentially throws. If it does, the error is passed to `captureException` and rethrown.\n *\n * Note: This function turns the wrapped function into an asynchronous one.\n */\nexport function withErrorInstrumentation<F extends (...args: any[]) => any>(\n  origFunction: F,\n): (...params: Parameters<F>) => Promise<ReturnType<F>> {\n  return async function (this: unknown, ...origFunctionArguments: Parameters<F>): Promise<ReturnType<F>> {\n    try {\n      return await origFunction.call(this, ...origFunctionArguments);\n    } catch (e) {\n      // TODO: Extract error logic from `withSentry` in here or create a new wrapper with said logic or something like that.\n      captureException(e);\n      throw e;\n    }\n  };\n}\n\n/**\n * Calls a server-side data fetching function (that takes a `req` and `res` object in its context) with tracing\n * instrumentation. A transaction will be created for the incoming request (if it doesn't already exist) in addition to\n * a span for the wrapped data fetching function.\n *\n * All of the above happens in an isolated domain, meaning all thrown errors will be associated with the correct span.\n *\n * @param origFunction The data fetching method to call.\n * @param origFunctionArguments The arguments to call the data fetching method with.\n * @param req The data fetching function's request object.\n * @param res The data fetching function's response object.\n * @param options Options providing details for the created transaction and span.\n * @returns what the data fetching method call returned.\n */\nexport function callTracedServerSideDataFetcher<F extends (...args: any[]) => Promise<any> | any>(\n  origFunction: F,\n  origFunctionArguments: Parameters<F>,\n  req: IncomingMessage,\n  res: ServerResponse,\n  options: {\n    /** Parameterized route of the request - will be used for naming the transaction. */\n    requestedRouteName: string;\n    /** Name of the route the data fetcher was defined in - will be used for describing the data fetcher's span. */\n    dataFetcherRouteName: string;\n    /** Name of the data fetching method - will be used for describing the data fetcher's span. */\n    dataFetchingMethodName: string;\n  },\n): Promise<ReturnType<F>> {\n  return domain.create().bind(async () => {\n    let requestTransaction: Transaction | undefined = getTransactionFromRequest(req);\n\n    if (requestTransaction === undefined) {\n      const sentryTraceHeader = req.headers['sentry-trace'];\n      const rawBaggageString = req.headers && req.headers.baggage;\n      const traceparentData =\n        typeof sentryTraceHeader === 'string' ? extractTraceparentData(sentryTraceHeader) : undefined;\n\n      const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(rawBaggageString);\n\n      const newTransaction = startTransaction(\n        {\n          op: 'http.server',\n          name: options.requestedRouteName,\n          ...traceparentData,\n          status: 'ok',\n          metadata: {\n            source: 'route',\n            dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,\n          },\n        },\n        { request: req },\n      );\n\n      requestTransaction = newTransaction;\n      autoEndTransactionOnResponseEnd(newTransaction, res);\n\n      // Link the transaction and the request together, so that when we would normally only have access to one, it's\n      // still possible to grab the other.\n      setTransactionOnRequest(newTransaction, req);\n      newTransaction.setMetadata({ request: req });\n    }\n\n    const dataFetcherSpan = requestTransaction.startChild({\n      op: 'function.nextjs',\n      description: `${options.dataFetchingMethodName} (${options.dataFetcherRouteName})`,\n      status: 'ok',\n    });\n\n    const currentScope = getCurrentHub().getScope();\n    if (currentScope) {\n      currentScope.setSpan(dataFetcherSpan);\n      currentScope.setSDKProcessingMetadata({ request: req });\n    }\n\n    try {\n      return await origFunction(...origFunctionArguments);\n    } catch (e) {\n      // Since we finish the span before the error can bubble up and trigger the handlers in `registerErrorInstrumentation`\n      // that set the transaction status, we need to manually set the status of the span & transaction\n      dataFetcherSpan.setStatus('internal_error');\n\n      const transaction = dataFetcherSpan.transaction;\n      if (transaction) {\n        transaction.setStatus('internal_error');\n      }\n\n      throw e;\n    } finally {\n      dataFetcherSpan.finish();\n    }\n  })();\n}\n\n/**\n * Call a data fetcher and trace it. Only traces the function if there is an active transaction on the scope.\n *\n * We only do the following until we move transaction creation into this function: When called, the wrapped function\n * will also update the name of the active transaction with a parameterized route provided via the `options` argument.\n */\nexport async function callDataFetcherTraced<F extends (...args: any[]) => Promise<any> | any>(\n  origFunction: F,\n  origFunctionArgs: Parameters<F>,\n  options: {\n    parameterizedRoute: string;\n    dataFetchingMethodName: string;\n  },\n): Promise<ReturnType<F>> {\n  const { parameterizedRoute, dataFetchingMethodName } = options;\n\n  const transaction = getActiveTransaction();\n\n  if (!transaction) {\n    return origFunction(...origFunctionArgs);\n  }\n\n  // TODO: Make sure that the given route matches the name of the active transaction (to prevent background data\n  // fetching from switching the name to a completely other route) -- We'll probably switch to creating a transaction\n  // right here so making that check will probabably not even be necessary.\n  // Logic will be: If there is no active transaction, start one with correct name and source. If there is an active\n  // transaction, create a child span with correct name and source.\n  transaction.name = parameterizedRoute;\n  transaction.metadata.source = 'route';\n\n  // Capture the route, since pre-loading, revalidation, etc might mean that this span may happen during another\n  // route's transaction\n  const span = transaction.startChild({\n    op: 'function.nextjs',\n    description: `${dataFetchingMethodName} (${parameterizedRoute})`,\n    status: 'ok',\n  });\n\n  try {\n    return await origFunction(...origFunctionArgs);\n  } catch (err) {\n    // Since we finish the span before the error can bubble up and trigger the handlers in `registerErrorInstrumentation`\n    // that set the transaction status, we need to manually set the status of the span & transaction\n    transaction.setStatus('internal_error');\n    span.setStatus('internal_error');\n    span.finish();\n\n    // TODO Copy more robust error handling over from `withSentry`\n    captureException(err);\n    throw err;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;"}