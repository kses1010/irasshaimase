var {
  _optionalChain
} = require('@sentry/utils/cjs/buildPolyfills');

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@sentry/core');
var integrations = require('@sentry/integrations');
var node = require('@sentry/node');
var tracing = require('@sentry/tracing');
var utils = require('@sentry/utils');
var domain$1 = require('domain');
var path = require('path');
var isBuild = require('./utils/isBuild.js');
var metadata = require('./utils/metadata.js');
var userIntegrations = require('./utils/userIntegrations.js');
var _error = require('./utils/_error.js');
var react = require('@sentry/react');
var index = require('./config/index.js');
require('./config/wrappers/index.js');
var withSentryGetServerSideProps = require('./config/wrappers/withSentryGetServerSideProps.js');
var withSentryGetStaticProps = require('./config/wrappers/withSentryGetStaticProps.js');
var withSentryServerSideGetInitialProps = require('./config/wrappers/withSentryServerSideGetInitialProps.js');
var withSentryServerSideAppGetInitialProps = require('./config/wrappers/withSentryServerSideAppGetInitialProps.js');
var withSentryServerSideDocumentGetInitialProps = require('./config/wrappers/withSentryServerSideDocumentGetInitialProps.js');
var withSentryServerSideErrorGetInitialProps = require('./config/wrappers/withSentryServerSideErrorGetInitialProps.js');
var withSentryAPI = require('./config/wrappers/withSentryAPI.js');

var domain = domain$1 ;

// Exporting this constant means we can compute it without the linter complaining, even if we stop directly using it in
// this file. It's important that it be computed as early as possible, because one of its indicators is seeing 'build'
// (as in the CLI command `next build`) in `process.argv`. Later on in the build process, everything's been spun out
// into child threads and `argv` turns into ['node', 'path/to/childProcess.js'], so the original indicator is lost. We
// thus want to compute it as soon as the SDK is loaded for the first time, which is normally when the user imports
// `withSentryConfig` into `next.config.js`.
var IS_BUILD = isBuild.isBuild();
var IS_VERCEL = !!process.env.VERCEL;

/** Inits the Sentry NextJS SDK on node. */
function init(options) {
  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && options.debug) {
    utils.logger.enable();
  }

  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.log('Initializing SDK...');

  if (sdkAlreadyInitialized()) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.log('SDK already initialized');
    return;
  }

  metadata.buildMetadata(options, ['nextjs', 'node']);
  options.environment = options.environment || process.env.NODE_ENV;
  addServerIntegrations(options);
  // Right now we only capture frontend sessions for Next.js
  options.autoSessionTracking = false;

  // In an ideal world, this init function would be called before any requests are handled. That way, every domain we
  // use to wrap a request would inherit its scope and client from the global hub. In practice, however, handling the
  // first request is what causes us to initialize the SDK, as the init code is injected into `_app` and all API route
  // handlers, and those are only accessed in the course of handling a request. As a result, we're already in a domain
  // when `init` is called. In order to compensate for this and mimic the ideal world scenario, we stash the active
  // domain, run `init` as normal, and then restore the domain afterwards, copying over data from the main hub as if we
  // really were inheriting.
  var activeDomain = domain.active;
  domain.active = null;

  node.init(options);

  var filterTransactions = event => {
    return event.type === 'transaction' && event.transaction === '/404' ? null : event;
  };

  filterTransactions.id = 'NextServer404TransactionFilter';

  node.configureScope(scope => {
    scope.setTag('runtime', 'node');
    if (IS_VERCEL) {
      scope.setTag('vercel', true);
    }

    scope.addEventProcessor(filterTransactions);
  });

  if (activeDomain) {
    var globalHub = core.getHubFromCarrier(core.getMainCarrier());
    var domainHub = core.getHubFromCarrier(activeDomain);

    // apply the changes made by `nodeInit` to the domain's hub also
    domainHub.bindClient(globalHub.getClient());
    _optionalChain([domainHub, 'access', _ => _.getScope, 'call', _2 => _2(), 'optionalAccess', _3 => _3.update, 'call', _4 => _4(globalHub.getScope())]);
    // `scope.update()` doesnâ€™t copy over event processors, so we have to add it manually
    _optionalChain([domainHub, 'access', _5 => _5.getScope, 'call', _6 => _6(), 'optionalAccess', _7 => _7.addEventProcessor, 'call', _8 => _8(filterTransactions)]);

    // restore the domain hub as the current one
    domain.active = activeDomain;
  }

  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.log('SDK successfully initialized');
}

function sdkAlreadyInitialized() {
  var hub = node.getCurrentHub();
  return !!hub.getClient();
}

function addServerIntegrations(options) {
  let integrations$1 = options.integrations || [];

  // This value is injected at build time, based on the output directory specified in the build config. Though a default
  // is set there, we set it here as well, just in case something has gone wrong with the injection.
  var distDirName = (global ).__rewriteFramesDistDir__ || '.next';
  // nextjs always puts the build directory at the project root level, which is also where you run `next start` from, so
  // we can read in the project directory from the currently running process
  var distDirAbsPath = path.resolve(process.cwd(), distDirName);
  var SOURCEMAP_FILENAME_REGEX = new RegExp(utils.escapeStringForRegex(distDirAbsPath));

  var defaultRewriteFramesIntegration = new integrations.RewriteFrames({
    iteratee: frame => {
      frame.filename = _optionalChain([frame, 'access', _9 => _9.filename, 'optionalAccess', _10 => _10.replace, 'call', _11 => _11(SOURCEMAP_FILENAME_REGEX, 'app:///_next')]);
      return frame;
    },
  });
  integrations$1 = userIntegrations.addOrUpdateIntegration(defaultRewriteFramesIntegration, integrations$1);

  var defaultRequestDataIntegration = new node.Integrations.RequestData();
  integrations$1 = userIntegrations.addOrUpdateIntegration(defaultRequestDataIntegration, integrations$1);

  if (tracing.hasTracingEnabled(options)) {
    var defaultHttpTracingIntegration = new node.Integrations.Http({ tracing: true });
    integrations$1 = userIntegrations.addOrUpdateIntegration(defaultHttpTracingIntegration, integrations$1, {
      _tracing: true,
    });
  }

  options.integrations = integrations$1;
}

// TODO (v8): Remove this
/**
 * @deprecated Use the constant `IS_BUILD` instead.
 */
var deprecatedIsBuild = () => isBuild.isBuild();

// Wrap various server methods to enable error monitoring and tracing. (Note: This only happens for non-Vercel
// deployments, because the current method of doing the wrapping a) crashes Next 12 apps deployed to Vercel and
// b) doesn't work on those apps anyway. We also don't do it during build, because there's no server running in that
// phase.)
if (!IS_BUILD && !IS_VERCEL) {
  // Dynamically require the file because even importing from it causes Next 12 to crash on Vercel.
  // In environments where the JS file doesn't exist, such as testing, import the TS file.
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { instrumentServer } = require('./utils/instrumentServer.js');
    instrumentServer();
  } catch (err) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.warn(`Error: Unable to instrument server for tracing. Got ${err}.`);
  }
}

exports.captureUnderscoreErrorException = _error.captureUnderscoreErrorException;
exports.ErrorBoundary = react.ErrorBoundary;
exports.showReportDialog = react.showReportDialog;
exports.withErrorBoundary = react.withErrorBoundary;
exports.withSentryConfig = index.withSentryConfig;
exports.withSentryGetServerSideProps = withSentryGetServerSideProps.withSentryGetServerSideProps;
exports.withSentryGetStaticProps = withSentryGetStaticProps.withSentryGetStaticProps;
exports.withSentryServerSideGetInitialProps = withSentryServerSideGetInitialProps.withSentryServerSideGetInitialProps;
exports.withSentryServerSideAppGetInitialProps = withSentryServerSideAppGetInitialProps.withSentryServerSideAppGetInitialProps;
exports.withSentryServerSideDocumentGetInitialProps = withSentryServerSideDocumentGetInitialProps.withSentryServerSideDocumentGetInitialProps;
exports.withSentryServerSideErrorGetInitialProps = withSentryServerSideErrorGetInitialProps.withSentryServerSideErrorGetInitialProps;
exports.withSentry = withSentryAPI.withSentry;
exports.withSentryAPI = withSentryAPI.withSentryAPI;
exports.IS_BUILD = IS_BUILD;
exports.init = init;
exports.isBuild = deprecatedIsBuild;
for (var k in node) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = node[k];
}
//# sourceMappingURL=index.server.js.map
