{"version":3,"file":"index.server.js","sources":["../../src/index.server.ts"],"sourcesContent":["import { Carrier, getHubFromCarrier, getMainCarrier } from '@sentry/core';\nimport { RewriteFrames } from '@sentry/integrations';\nimport { configureScope, getCurrentHub, init as nodeInit, Integrations } from '@sentry/node';\nimport { hasTracingEnabled } from '@sentry/tracing';\nimport { EventProcessor } from '@sentry/types';\nimport { escapeStringForRegex, logger } from '@sentry/utils';\nimport * as domainModule from 'domain';\nimport * as path from 'path';\n\nimport { isBuild } from './utils/isBuild';\nimport { buildMetadata } from './utils/metadata';\nimport { NextjsOptions } from './utils/nextjsOptions';\nimport { addOrUpdateIntegration } from './utils/userIntegrations';\n\nexport * from '@sentry/node';\nexport { captureUnderscoreErrorException } from './utils/_error';\n\n// Here we want to make sure to only include what doesn't have browser specifics\n// because or SSR of next.js we can only use this.\nexport { ErrorBoundary, showReportDialog, withErrorBoundary } from '@sentry/react';\n\ntype GlobalWithDistDir = typeof global & { __rewriteFramesDistDir__: string };\nconst domain = domainModule as typeof domainModule & { active: (domainModule.Domain & Carrier) | null };\n\n// Exporting this constant means we can compute it without the linter complaining, even if we stop directly using it in\n// this file. It's important that it be computed as early as possible, because one of its indicators is seeing 'build'\n// (as in the CLI command `next build`) in `process.argv`. Later on in the build process, everything's been spun out\n// into child threads and `argv` turns into ['node', 'path/to/childProcess.js'], so the original indicator is lost. We\n// thus want to compute it as soon as the SDK is loaded for the first time, which is normally when the user imports\n// `withSentryConfig` into `next.config.js`.\nexport const IS_BUILD = isBuild();\nconst IS_VERCEL = !!process.env.VERCEL;\n\n/** Inits the Sentry NextJS SDK on node. */\nexport function init(options: NextjsOptions): void {\n  if (__DEBUG_BUILD__ && options.debug) {\n    logger.enable();\n  }\n\n  __DEBUG_BUILD__ && logger.log('Initializing SDK...');\n\n  if (sdkAlreadyInitialized()) {\n    __DEBUG_BUILD__ && logger.log('SDK already initialized');\n    return;\n  }\n\n  buildMetadata(options, ['nextjs', 'node']);\n  options.environment = options.environment || process.env.NODE_ENV;\n  addServerIntegrations(options);\n  // Right now we only capture frontend sessions for Next.js\n  options.autoSessionTracking = false;\n\n  // In an ideal world, this init function would be called before any requests are handled. That way, every domain we\n  // use to wrap a request would inherit its scope and client from the global hub. In practice, however, handling the\n  // first request is what causes us to initialize the SDK, as the init code is injected into `_app` and all API route\n  // handlers, and those are only accessed in the course of handling a request. As a result, we're already in a domain\n  // when `init` is called. In order to compensate for this and mimic the ideal world scenario, we stash the active\n  // domain, run `init` as normal, and then restore the domain afterwards, copying over data from the main hub as if we\n  // really were inheriting.\n  const activeDomain = domain.active;\n  domain.active = null;\n\n  nodeInit(options);\n\n  const filterTransactions: EventProcessor = event => {\n    return event.type === 'transaction' && event.transaction === '/404' ? null : event;\n  };\n\n  filterTransactions.id = 'NextServer404TransactionFilter';\n\n  configureScope(scope => {\n    scope.setTag('runtime', 'node');\n    if (IS_VERCEL) {\n      scope.setTag('vercel', true);\n    }\n\n    scope.addEventProcessor(filterTransactions);\n  });\n\n  if (activeDomain) {\n    const globalHub = getHubFromCarrier(getMainCarrier());\n    const domainHub = getHubFromCarrier(activeDomain);\n\n    // apply the changes made by `nodeInit` to the domain's hub also\n    domainHub.bindClient(globalHub.getClient());\n    domainHub.getScope()?.update(globalHub.getScope());\n    // `scope.update()` doesnâ€™t copy over event processors, so we have to add it manually\n    domainHub.getScope()?.addEventProcessor(filterTransactions);\n\n    // restore the domain hub as the current one\n    domain.active = activeDomain;\n  }\n\n  __DEBUG_BUILD__ && logger.log('SDK successfully initialized');\n}\n\nfunction sdkAlreadyInitialized(): boolean {\n  const hub = getCurrentHub();\n  return !!hub.getClient();\n}\n\nfunction addServerIntegrations(options: NextjsOptions): void {\n  let integrations = options.integrations || [];\n\n  // This value is injected at build time, based on the output directory specified in the build config. Though a default\n  // is set there, we set it here as well, just in case something has gone wrong with the injection.\n  const distDirName = (global as GlobalWithDistDir).__rewriteFramesDistDir__ || '.next';\n  // nextjs always puts the build directory at the project root level, which is also where you run `next start` from, so\n  // we can read in the project directory from the currently running process\n  const distDirAbsPath = path.resolve(process.cwd(), distDirName);\n  const SOURCEMAP_FILENAME_REGEX = new RegExp(escapeStringForRegex(distDirAbsPath));\n\n  const defaultRewriteFramesIntegration = new RewriteFrames({\n    iteratee: frame => {\n      frame.filename = frame.filename?.replace(SOURCEMAP_FILENAME_REGEX, 'app:///_next');\n      return frame;\n    },\n  });\n  integrations = addOrUpdateIntegration(defaultRewriteFramesIntegration, integrations);\n\n  const defaultRequestDataIntegration = new Integrations.RequestData();\n  integrations = addOrUpdateIntegration(defaultRequestDataIntegration, integrations);\n\n  if (hasTracingEnabled(options)) {\n    const defaultHttpTracingIntegration = new Integrations.Http({ tracing: true });\n    integrations = addOrUpdateIntegration(defaultHttpTracingIntegration, integrations, {\n      _tracing: true,\n    });\n  }\n\n  options.integrations = integrations;\n}\n\n// TODO (v8): Remove this\n/**\n * @deprecated Use the constant `IS_BUILD` instead.\n */\nconst deprecatedIsBuild = (): boolean => isBuild();\n// eslint-disable-next-line deprecation/deprecation\nexport { deprecatedIsBuild as isBuild };\n\nexport type { SentryWebpackPluginOptions } from './config/types';\nexport { withSentryConfig } from './config';\nexport {\n  withSentryGetServerSideProps,\n  withSentryGetStaticProps,\n  withSentryServerSideGetInitialProps,\n  withSentryServerSideAppGetInitialProps,\n  withSentryServerSideDocumentGetInitialProps,\n  withSentryServerSideErrorGetInitialProps,\n  withSentryAPI,\n  withSentry,\n} from './config/wrappers';\n\n// Wrap various server methods to enable error monitoring and tracing. (Note: This only happens for non-Vercel\n// deployments, because the current method of doing the wrapping a) crashes Next 12 apps deployed to Vercel and\n// b) doesn't work on those apps anyway. We also don't do it during build, because there's no server running in that\n// phase.)\nif (!IS_BUILD && !IS_VERCEL) {\n  // Dynamically require the file because even importing from it causes Next 12 to crash on Vercel.\n  // In environments where the JS file doesn't exist, such as testing, import the TS file.\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { instrumentServer } = require('./utils/instrumentServer.js');\n    instrumentServer();\n  } catch (err) {\n    __DEBUG_BUILD__ && logger.warn(`Error: Unable to instrument server for tracing. Got ${err}.`);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6DA;;AAEA;;;AAGA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;AAEA;AACA;;;;;AAoBA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;"}